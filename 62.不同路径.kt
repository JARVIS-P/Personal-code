/**
 * 62.不同路径
 *
 * 方法一：动态规划
 * 由于每一步只能往下或往右行走，因此每一格的路径数都等于其左侧及上侧的路径数之和，因此我们就可以得出状态转移方程(dp[i][j]=dp[i-][j]+dp[i][j-])
 * 倘若你能找出下一步结果与当前结果的联系，那么我们就可以列出状态转移方程进行动态规划
 *
 * 方法二：数学方法
 * 从左上角到右下角的过程中，我们需要移动m+n-2次，其中有m-1次向下移动，n-1次向右移动。因此路径的总数，就等于从m+n-2次移动中选择m-1次向下移动的方案数
 *
 */
fun uniquePaths(m:Int ,n:Int):Int{
    if(m==0||n==0) return 0

    val dp=Array(m){IntArray(n)}

    //初始化dp数组的第0行和第0列(这几个点能到达的路径数只有1个)
    for(i in 0 until m){
        dp[i][0]=1
    }
    for(i in 0 until n){
        dp[0][i]=1
    }

    for(i in 1 until m){
        for(j in 1 until n){
            dp[i][j]=dp[i-1][j]+dp[i][j-1]//根据状态转移方程进行递推
        }
    }

    return dp[m-1][n-1]
}